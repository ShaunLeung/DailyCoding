# Shaun Leung
# Jan 23, 2022

"""
This one is going to be a fun one! There are basically two problems in here.

The fist is to detect any cycles. If one is found you get to return NULL

The second problem is to find long paths, the problem here is that they don't 
give a starting node so you need to consider each node as a possible start. 
As far as searching the paths the best way to do this would be by using a 
modified Dijkstra's algorithm but instead of searching for small path lengths
you search for long ones, and since we know that the graph contains no cycles
we can just spit out the longest path length that we get.
"""


from re import M


def buildMatrix(nodes, vertices):
    """
    Takes a list of nodes and vertices and turns it into an adjancency matrix
    """
    n = len(nodes)
    matrix = [[0 for _ in range(n)] for _ in range(n)]

    for vertex in vertices:
        i, j = vertex
        matrix[i][j] = 1

    return matrix


def hasCycle(matrix, node,  seen):
    """
    Recursively check the for a cycle in the graph, if one is found True will 
    bubble up from the recursion. Else False. 
    """
    if node in seen:
        return True
    else:
        seen.append(node)

    for i in range(len(matrix[node])):
        if matrix[node][i] == 1:
            return hasCycle(matrix, i, seen)

    return False


# Testing has cycle
nodes = "ABACA"
vertices = [(0, 1),
            (0, 2),
            (2, 3),
            (3, 4)]
matrix = buildMatrix(nodes, vertices)


for i in range(len(matrix)):
    seen = []
    if hasCycle(matrix, i, seen):
        print("Cycle wrongly detected")

nodes = "A"
vertices = [(0, 0)]
matrix = buildMatrix(nodes, vertices)

for i in range(len(matrix)):
    seen = []
    if not hasCycle(matrix, i, seen):
        print("Cycle wrongly detected")


def longestPath(node, matrix, dijk=None):
    """
    An augmented version of Dijkstra's algorith but instead of searching for the
    smallest path it is looking for the longest path. It returns the matrix dijk
    so that the longest path can be unwound from the data. 
    """
    n = len(matrix)

    # set up the matrix for Dijkstra's algorithm.
    if not dijk:
        dijk = [[0 for _ in range(2)] for _ in range(n)]
        for i in range(n):
            dijk[i][0] = float("-inf")
            dijk[i][1] = None

        dijk[node][0] = 0  # fill in info for current node

    steps = dijk[node][0]

    for i in range(len(matrix[node])):
        if matrix[node][i] == 1 and dijk[i][0] < steps+1:
            # update dijk
            dijk[i][0] = steps+1    # update steps
            dijk[i][1] = node       # update prev
            dijk = longestPath(i, matrix, dijk)  # recurse

    return dijk


def unwindMax(dijk):
    """
    Takes a matrix generated by the longest path function and returns
    an array that represents the longest path.
    """
    path = []
    max = -1
    index = None
    # find longest path
    for i in range(len(dijk)):
        if dijk[i][0] > max:
            index = i
            max = dijk[i][0]

    next = dijk[index][1]
    path.append(index)
    while next != None:
        index = next
        next = dijk[index][1]
        path.append(index)

    path.reverse()
    return path


def lableNodes(nodes, path):
    """
    Takes an array generated by unwindMax and applies the lables from Nodes.
    Returns the now labled path.
    """
    labledPath = []
    for node in path:
        labledPath.append(nodes[node])
    return labledPath


def findLongestPath(nodes, vertices):
    """
    The function that puts everything together.
    Checks for cycles, finds the longest path
    Decodes the longest path. 
    """
    matrix = buildMatrix(nodes, vertices)
    # check for cycles
    for i in range(len(nodes)):
        if hasCycle(matrix, i, []):
            return None

    longest = ''

    for i in range(len(nodes)):
        dijk = longestPath(i, matrix)
        path = unwindMax(dijk)
        path = lableNodes(nodes, path)
        if len(path) > len(longest):
            longest = path

    return longest


nodes = "ABACA"
vertices = [(0, 1),
            (0, 2),
            (2, 3),
            (3, 4)]

print(findLongestPath(nodes, vertices))
